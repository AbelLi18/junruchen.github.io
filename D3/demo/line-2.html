<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 -- 折线图</title>
  <style>
    * {
      box-sizing: border-box;
    }

    p, div {
      padding: 0;
      margin: 0;
    }

    button {
      width: 100px;
      line-height: 36px;
      outline: none;
      border: 1px solid #58a;
      background-color: #fff;
      margin-bottom: 20px;
      cursor: pointer;
    }

    button:hover {
      color: #fff;
      background-color: #58a;
      transition: all .2s linear;
    }

    svg {
      border: 1px solid;
    }

    .line-box {
      width: 440px;
      height: 440px;
    }

    .line-demo {
      position: relative;
    }

    .line-tips {
      display: none;
      position: absolute;
      padding: 5px;
      border-radius: 4px;
      min-width: 100px;
      font-size: 12px;
      background-color: rgba(0, 0, 0, .3);
      color: #fff;
    }

    .tip-content-i {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 5px;
      vertical-align: middle;
    }

  </style>
</head>
<body>
<div class="d3-container">
  <button onclick="updateData()">更新数据</button>
  <button onclick="addData()">增加数据</button>
  <button onclick="delData()">删除数据</button>
  <button onclick="addLine()">增加折线</button>
  <button onclick="delline()">删除折线</button>

  <div class="line-box">
    <div class="line-demo">
      <div class="line-tips"></div>
    </div>
  </div>
</div>
</body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
  /**
   * 分析：折线图 （包含：线、坐标系、文字）
   * 线：path
   * 文字：text
   * 坐标系：线性
   * */

    // 用户指定
  let paddingT = 40
  let paddingB = 80
  let paddingL = 60
  let paddingR = 40
  let color = ['#5588AA', '#FFBB33', 'red', 'green', 'purple', 'black', '#cccccc']
  let lineData = {
    label: ['中国', '日本'],
    xAxis: {
      title: '日期',
      data: ['2000', '2001', '2002', '2003', '2004', '2005', '2006', '2007', '2008', '2009', '2010', '2011']
    },
    yAxis: {
      title: 'GDP'
    },
    series: [
      [
        {val: '11920', time: '2000'}, {val: '13170', time: '2001'}, {val: '14550', time: '2002'},
        {val: '16500', time: '2003'}, {val: '19440', time: '2004'}, {val: '22870', time: '2005'},
        {val: '27930', time: '2006'}, {val: '35040', time: '2007'}, {val: '45470', time: '2008'},
        {val: '51050', time: '2009'}, {val: '59490', time: '2010'}, {val: '73140', time: '2011'}
      ],
      [
        {val: '47310', time: '2000'}, {val: '41950', time: '2001'}, {val: '39800', time: '2002'},
        {val: '43020', time: '2003'}, {val: '46550', time: '2004'}, {val: '45710', time: '2005'},
        {val: '43560', time: '2006'}, {val: '43560', time: '2007'}, {val: '48490', time: '2008'},
        {val: '50350', time: '2009'}, {val: '54950', time: '2010'}, {val: '59050', time: '2011'}
      ]
    ]
  }

  // 全局变量
  let width = parseInt(d3.select('.line-box').style('width'))
  let height = parseInt(d3.select('.line-box').style('height'))
  let lineWidth = width - paddingL - paddingR
  let lineHeight = height - paddingT - paddingB
  let svg = d3.select('.line-demo')
    .append('svg')
    .attr('width', width)
    .attr('height', height)
  let xScale = d3.scaleLinear()
  let yScale = d3.scaleLinear()

  drawLine()
  mousemove() // 控制tip

  function drawLine () {
    drawLabel() // 绘制label
    drawAxis() // 绘制坐标系
    drawArea() //绘制路径背景 -----> 动画有问题
    drawPath() // 绘制路径
    drawCircle() // 绘制圆点
  }

  function drawLabel () {
    // label
    let labelG = svg.selectAll('.label').data(lineData.label)
    let enterLabel = labelG.enter().append('g')

    labelG.selectAll('text')
      .text((d) => {
        return d
      })

    enterLabel
      .attr('class', 'label')
      .append('rect')
      .attr('width', '23')
      .attr('height', '13')
      .attr('stroke-width', 0)
      .attr('fill', (d, i) => {
        return color[i]
      })
      .attr('x', (d, i) => {
        return paddingL + i * 80
      })
      .attr('y', lineHeight + paddingT + 40)
      .attr('rx', '2')
    enterLabel.append('text')
      .attr('x', (d, i) => {
        return paddingL + i * 80
      })
      .attr('y', lineHeight + paddingT + 40)
      .attr('dx', '28')
      .attr('dy', '.5rem')
      .attr('font-size', '12')
      .attr('text-anthor', 'middle')
      .attr('stroke-width', 0)
      .text((d) => {
        return d
      })

    // del
    labelG.exit().remove()

  }
  function drawAxis () {
    // 绘制坐标系
    xScale.domain([d3.min(lineData.xAxis.data), d3.max(lineData.xAxis.data)])
      .range([0, lineWidth])
    let xAxis = d3.axisBottom(xScale)
      .ticks(5)
    let gXaxis = svg.select('.xAxis')
      .call(xAxis)
      .attr('transform', 'translate(' + paddingL + ',' + (height - paddingB) + ')')

    if (gXaxis.size() === 0) {
      gXaxis = svg.append('g')
        .call(xAxis)
        .attr('class', 'xAxis')
        .attr('transform', 'translate(' + paddingL + ',' + (height - paddingB) + ')')
        .append('text')
        .text(lineData.xAxis.title)
        .attr('stroke-width', 0)
        .attr('fill', 'black')
        .attr('transform', 'translate(' + lineWidth + ', 0)')
        .attr('dx', '1rem')
    }

    let maxData = getMax()
    yScale.domain([0, maxData])
      .range([lineHeight, 0])
    let yAxis = d3.axisLeft()
      .scale(yScale)
      .ticks(5)
    let gYaxis = svg.select('.yAxis')
      .call(yAxis)
      .attr('transform', 'translate(' + paddingL + ',' + paddingT + ')')

    if (gYaxis.size() === 0) {
      gYaxis = svg.append('g')
        .call(yAxis)
        .attr('class', 'yAxis')
        .attr('transform', 'translate(' + paddingL + ',' + paddingT + ')')
        .append('text')
        .text(lineData.yAxis.title)
        .attr('stroke-width', 0)
        .attr('fill', 'black')
        .attr('text-anthor', 'middle')
    }
  }
  function drawPath () {
    let line = d3.line()
      .x((d) => {
        return xScale(d.time)
      })
      .y((d) => {
        return yScale(d.val) + paddingT
      })
    let path = svg.selectAll('.line-path').data(lineData.series)
    let enterPath = path.enter()
    // update
    path
      .attr('d', (d) => {
        return line(d)
      })
      .attr('stroke-dasharray', function () {
        return this.getTotalLength()
      })
      .attr('stroke-dashoffset', function () {
        let lastOffSet = d3.select(this).attr('data-offset')
        d3.select(this).attr('data-offset', this.getTotalLength())
        let newOffSet = this.getTotalLength() - lastOffSet
        return newOffSet > 0 ? newOffSet : 0
      })
      .transition()
      .duration(500)
      .attr('stroke-dashoffset', 0)

    enterPath.append('path').attr('class', 'line-path')
      .attr('d', (d) => {
        return line(d)
      })
      .attr('stroke', function (d, i) {
        return color[i]
      })
      .attr('fill', 'none')
      .attr('transform', 'translate(' + paddingL + ')')
      .attr('stroke-dasharray', function () {
        d3.select(this).attr('data-offset', this.getTotalLength())
        return this.getTotalLength()
      })
      .attr('stroke-dashoffset', function () {
        return this.getTotalLength()
      })
      .transition()
      .duration(1000)
      .attr('stroke-dashoffset', 0)

    // del
    path.exit().remove()
  }
  function drawArea () {
    let areaLine = d3.area()
      .x((d) => {
        return xScale(d.time)
      })
      .y0(() => {
        return height - paddingB
      })
      .y1((d) => {
        return yScale(d.val) + paddingT
      })

    let areaPath = svg.selectAll('.line-areapath').data(lineData.series)
    let enterAreaPath = areaPath.enter()

    // update
    areaPath
      .attr('d', (d) => {
        return areaLine(d)
      })

    // add
    enterAreaPath.append('path').attr('class', 'line-areapath')
      .attr('d', (d) => {
        return areaLine(d)
      })
      .attr('stroke', 'none')
      .attr('fill', (d, i) => {
        return color[i]
      })
      .attr('fill-opacity', '.3')
      .attr('transform', 'translate(' + paddingL + ')')
    enterAreaPath.append('rect')
      .attr('class', 'path-area-mark')
      .attr('width', lineWidth)
      .attr('height', lineHeight)
      .attr('x', paddingL + 1)
      .attr('y', paddingT)
      .attr('fill', '#fff')
      .attr('transform-origin', 'right center')
      .transition()
      .duration(1000)
      .attr('transform', 'scale(0, 1)')

    // del
    areaPath.exit().remove()
  }
  function drawCircle () {
    let circleG = svg.selectAll('.line-circle')
      .data(lineData.series)
    let enterCircleG = circleG.enter()

    // add
    enterCircleG.append('g')
      .attr('class', 'line-circle')
      .attr('id', (d, i) => {
        return 'line-circle' + i
      })
      .attr('transform', 'translate(' + paddingL + ', ' + paddingT + ')')
      .attr('fill', (d, i) => {
        return color[i]
      })
    // del
    circleG.exit().remove()

    lineData.series.forEach((item, idx) => {
      let parentG = svg.selectAll('#line-circle' + idx)
      circle(item, parentG)
    })
  }
  function circle (data, circleG) {
    let circle = circleG.selectAll('circle')
      .data(data)
    let enterCircle = circle.enter()

    // update
    circle
      .attr('cx', (d) => {
        return xScale(d.time)
      })
      .attr('cy', (d) => {
        return yScale(d.val)
      })
    // add
    enterCircle
      .append('circle')
      .attr('cx', (d) => {
        return xScale(d.time)
      })
      .attr('cy', (d) => {
        return yScale(d.val)
      })
      .attr('r', 3.5)
      .style('cursor', 'pointer')
      .on('mouseover', function () {
        d3.select(this).transition().duration(100).attr('r', 5)
      })
      .on('mouseout', function () {
        d3.select(this).transition().duration(50).attr('r', 3.6)
      })
    // del
    circle.exit().remove()
  }
  function mousemove () {
    let tipsRect = svg.append('rect')
      .attr('class', 'mousemove-rect')
      .attr('width', lineWidth)
      .attr('height', lineWidth)
      .attr('x', paddingL)
      .attr('y', paddingT)
      .attr('fill', 'none')
      .style('pointer-events', 'all')
      .on('mouseover', function () {
        d3.select('.line-tips').transition().duration(200).style('display', 'block')
        d3.select('.verline-tips-group').transition().duration(200).style('display', 'block')
      })
      .on('mouseout', function () {
        d3.select('.line-tips').transition().duration(100).style('display', 'none')
        d3.select('.verline-tips-group').transition().duration(200).style('display', 'none')
      })
      .on('mousemove', drawTip)
  }
  function drawTip () {
    var bisect = d3.bisector(function (d) {
      return d
    }).left

    // 获取x轴坐标
    let x0 = xScale.invert(d3.mouse(this)[0] - paddingL),
      i = bisect(lineData.xAxis.data, x0),
      d0 = lineData.xAxis.data[i - 1],
      d1 = lineData.xAxis.data[i],
      d = (x0 - d0) > (d1 - x0) ? d1 : d0

    // 获取交点 y轴坐标 ------>有问题
    let points = []
    lineData.series.forEach((item) => {
      item.forEach((ditem) => {
        if (parseInt(ditem.time) === parseInt(d)) {
          points.push(ditem.val)
        }
      })
    })

    // 绘制垂直线以及圆点
    let tipsLine = d3.selectAll('.verline-tips-group')
    tipsLine.selectAll('.verline-tips').attr('x1', xScale(d) + paddingL)
      .attr('x2', xScale(d) + paddingL)
    if (tipsLine.size() === 0) {
      svg.append('g')
        .attr('class', 'verline-tips-group')
        .append('line')
        .attr('class', 'verline-tips')
        .attr('x1', xScale(d))
        .attr('y1', paddingT)
        .attr('x2', xScale(d))
        .attr('y2', height - paddingB)
        .attr('stroke', '#999')
        .on('mouseover', function () {
          d3.select('.line-tips').transition().duration(200).style('display', 'block')
          d3.select('.verline-tips-group').transition().duration(200).style('display', 'block')
        })
        .on('mouseout', function () {
          d3.select('.line-tips').transition().duration(100).style('display', 'block')
          d3.select('.verline-tips-group').transition().duration(200).style('display', 'block')
        })
    }
    let tipsLineCircle = tipsLine.selectAll('.verline-tips-circle').data(points)
    tipsLineCircle
      .attr('cx', xScale(d) + paddingL)
      .attr('cy', (d) => {
        return yScale(d) + paddingT
      })
    let enterTipsLineCircle = tipsLineCircle.enter()
    enterTipsLineCircle.append('circle')
      .attr('class', 'verline-tips-circle')
      .attr('r', 5)
      .attr('cx', xScale(d) + paddingL)
      .attr('cy', (d) => {
        return yScale(d) + paddingT
      })
      .attr('fill', (d, i) => {
        return color[i]
      })
      .on('mouseover', function () {
        d3.select('.line-tips').transition().duration(200).style('display', 'block')
        d3.select('.verline-tips-group').transition().duration(200).style('display', 'block')
      })
      .on('mouseout', function () {
        d3.select('.line-tips').transition().duration(100).style('display', 'block')
        d3.select('.verline-tips-group').transition().duration(200).style('display', 'block')
      })
    tipsLineCircle.exit().remove()

    // tip框填充相应文字数据
    let tips = d3.select('.line-tips')
    let tipsTitle = tips.selectAll('.tip-title')
    tipsTitle.text('年份: ' + d)
    if (tipsTitle.size() === 0) {
      tips.append('p')
        .attr('class', 'tip-title')
        .text('年份: ' + d)
    }
    let tipsPoint = tips.selectAll('.tip-content').data(points)
    console.log(tipsPoint.size())
    tipsPoint.select('span')
      .text((d, i) => {
        return lineData.label[i] + ' GDB: ' + d
      })

    let enterTipsPoint = tipsPoint.enter()
    let tipsPointDiv = enterTipsPoint
      .append('div')
      .attr('class', 'tip-content')
    tipsPointDiv.append('i')
      .attr('class', 'tip-content-i')
      .style('background-color', (d, i) => {
        return color[i]
      })
    tipsPointDiv.append('span')
      .text((d, i) => {
        return lineData.label[i] + ' GDB: ' + d
      })
    tipsPoint.exit().remove()

    // tip框位置处理 边界处理  parseInt(tips.style('width'))
    let widthSum = xScale(d) + paddingL + 10 + parseInt(tips.style('width'))
    let tipsLeft = (xScale(d) + paddingL + 10) + 'px'
    let tipsTop = (yScale(d3.mean(points)) + paddingT - parseInt(tips.style('height')) / 2) + 'px'

    if (widthSum > width) {
      tipsLeft = (width - parseInt(tips.style('width')) - paddingR - 10) + 'px'
    }
    tips.style('left', tipsLeft)
      .style('top', tipsTop)
  }

  function getMax () {
    let maxData = []
    lineData.series.forEach((item, idx) => {
      let itemMax = d3.max(item, (d) => {
        return d.val
      })
      maxData.push(itemMax)
    })
    return d3.max(maxData)
  }

  /*function updateData () {
   lineData.forEach((item, idx) => {
   item.gdp.forEach((iitem) => {
   iitem[1] = Math.floor(Math.random() * 100000)
   })
   })
   drawLine()
   }
   function addData () {
   lineData.forEach((item, idx) => {
   let year = idx === 0 ? getAxis(1) + 1 : getAxis(1)
   let newData = [year, Math.floor(Math.random() * 100000)]
   item.gdp.push(newData)
   })
   drawLine()
   }
   function addLine () {
   let newLine = {
   country: 'test' + lineData.length,
   gdp: []
   }
   lineData[0].gdp.forEach((item, idx) => {
   let data = [item[0], Math.floor(Math.random() * 100000)]
   newLine.gdp.push(data)
   })
   lineData.push(newLine)
   drawLine()
   }
   function delData () {
   lineData.forEach((item, idx) => {
   item.gdp.pop()
   })
   drawLine()
   }
   function delline () {
   lineData.pop()
   drawLine()
   }*/

</script>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 -- line</title>
  <style>
    * {
      box-sizing: border-box;
    }

    p, div {
      padding: 0;
      margin: 0;
    }

    svg {
      border: 1px solid;
    }

    .line-box {
      width: 100%;
      height: 340px;
    }

    .line-chart-d3 {
      position: relative;
    }

    .chart-title {
      position: absolute;
      font-size: 20px;
      color: #333;
    }

    .legends-group, .tips-content {
      position: absolute;
      font-size: 12px;
    }

    .tips-content {
      display: none;
      padding: 5px;
      border-radius: 4px;
      min-width: 100px;
      max-width: 200px;
      background-color: rgba(0, 0, 0, .4);
      color: #fff;
    }

    .legends-group .legend-item {
      display: inline-block;
      color: #333;
      padding-left: 10px;
    }

    .legends-group .legend-item .legend-i, .tips-content .tip-item .tip-i {
      display: inline-block;
      vertical-align: middle;
      height: 13px;
      margin-right: 5px;
    }

    .legends-group .legend-item .legend-i {
      opacity: 1;
      width: 23px;
      border-radius: 3px;
      cursor: pointer;
    }

    .tips-content .tip-item .tip-i {
      width: 13px;
      border-radius: 50%;
    }

  </style>
</head>
<body>
<div class="d3-container">
  <div class="line-box">

    <div class="line-chart-d3">
      <div class="chart-title"></div>
      <div class="legends-group"></div>
      <div class="tips-content"></div>
    </div>

  </div>
</div>
</body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
  // 用户指定
  let paddingT = 60
  let paddingB = 60
  let paddingL = 60
  let paddingR = 40
  let color = ['#5588AA', '#FFBB33', 'red', 'green', 'purple', 'black', '#cccccc']

  let lineData = {
    'title': 'QPS',
    'legend': ['QPS READ', 'QPS WRITE'],
    'yAxis': {
      'title': 'GDP'
    },
    'xAxis': {
      'title': '日期',
      'data': ['2017-06-22 17:01:16', '2017-06-22 17:01:36', '2017-06-22 17:01:56', '2017-06-22 17:02:16', '2017-06-22 17:02:36', '2017-06-22 17:02:56', '2017-06-22 17:03:16', '2017-06-22 17:03:36', '2017-06-22 17:03:56', '2017-06-22 17:04:16', '2017-06-22 17:04:36', '2017-06-22 17:04:56', '2017-06-22 17:05:16', '2017-06-22 17:05:36', '2017-06-22 17:05:56', '2017-06-22 17:06:16', '2017-06-22 17:06:36', '2017-06-22 17:06:56', '2017-06-22 17:07:16', '2017-06-22 17:07:36', '2017-06-22 17:07:56', '2017-06-22 17:08:16', '2017-06-22 17:08:36', '2017-06-22 17:08:56', '2017-06-22 17:09:16', '2017-06-22 17:09:36', '2017-06-22 17:09:56', '2017-06-22 17:10:16', '2017-06-22 17:10:36', '2017-06-22 17:10:56', '2017-06-22 17:11:16', '2017-06-22 17:11:36', '2017-06-22 17:11:56', '2017-06-22 17:12:16', '2017-06-22 17:12:36', '2017-06-22 17:12:56', '2017-06-22 17:13:16', '2017-06-22 17:13:36', '2017-06-22 17:13:56', '2017-06-22 17:14:16', '2017-06-22 17:14:36', '2017-06-22 17:14:56', '2017-06-22 17:15:16', '2017-06-22 17:15:36', '2017-06-22 17:15:56', '2017-06-22 17:16:16', '2017-06-22 17:16:36', '2017-06-22 17:16:56', '2017-06-22 17:17:16', '2017-06-22 17:17:36']
    },
    'series': [
      [{'data': 3356, 'time': '2017-06-22 17:01:16'}, {
        'data': 3338,
        'time': '2017-06-22 17:01:36'
      }, {'data': 9646, 'time': '2017-06-22 17:01:56'}, {
        'data': 3379,
        'time': '2017-06-22 17:02:16'
      }, {'data': 7872, 'time': '2017-06-22 17:02:36'}, {
        'data': 6584,
        'time': '2017-06-22 17:02:56'
      }, {'data': 6985, 'time': '2017-06-22 17:03:16'}, {
        'data': 2661,
        'time': '2017-06-22 17:03:36'
      }, {'data': 6921, 'time': '2017-06-22 17:03:56'}, {
        'data': 7087,
        'time': '2017-06-22 17:04:16'
      }, {'data': 4514, 'time': '2017-06-22 17:04:36'}, {
        'data': 9251,
        'time': '2017-06-22 17:04:56'
      }, {'data': 5592, 'time': '2017-06-22 17:05:16'}, {
        'data': 5846,
        'time': '2017-06-22 17:05:36'
      }, {'data': 5508, 'time': '2017-06-22 17:05:56'}, {
        'data': 7787,
        'time': '2017-06-22 17:06:16'
      }, {'data': 3246, 'time': '2017-06-22 17:06:36'}, {
        'data': 8543,
        'time': '2017-06-22 17:06:56'
      }, {'data': 8258, 'time': '2017-06-22 17:07:16'}, {
        'data': 9142,
        'time': '2017-06-22 17:07:36'
      }, {'data': 6821, 'time': '2017-06-22 17:07:56'}, {
        'data': 2585,
        'time': '2017-06-22 17:08:16'
      }, {'data': 35, 'time': '2017-06-22 17:08:36'}, {
        'data': 1300,
        'time': '2017-06-22 17:08:56'
      }, {'data': 4649, 'time': '2017-06-22 17:09:16'}, {
        'data': 2115,
        'time': '2017-06-22 17:09:36'
      }, {'data': 701, 'time': '2017-06-22 17:09:56'}, {
        'data': 9965,
        'time': '2017-06-22 17:10:16'
      }, {'data': 4072, 'time': '2017-06-22 17:10:36'}, {
        'data': 1592,
        'time': '2017-06-22 17:10:56'
      }, {'data': 2367, 'time': '2017-06-22 17:11:16'}, {
        'data': 175,
        'time': '2017-06-22 17:11:36'
      }, {'data': 7757, 'time': '2017-06-22 17:11:56'}, {
        'data': 3794,
        'time': '2017-06-22 17:12:16'
      }, {'data': 1629, 'time': '2017-06-22 17:12:36'}, {
        'data': 4911,
        'time': '2017-06-22 17:12:56'
      }, {'data': 4976, 'time': '2017-06-22 17:13:16'}, {
        'data': 245,
        'time': '2017-06-22 17:13:36'
      }, {'data': 3648, 'time': '2017-06-22 17:13:56'}, {
        'data': 6198,
        'time': '2017-06-22 17:14:16'
      }, {'data': 1248, 'time': '2017-06-22 17:14:36'}, {
        'data': 7314,
        'time': '2017-06-22 17:14:56'
      }, {'data': 1592, 'time': '2017-06-22 17:15:16'}, {
        'data': 1253,
        'time': '2017-06-22 17:15:36'
      }, {'data': 747, 'time': '2017-06-22 17:15:56'}, {
        'data': 6343,
        'time': '2017-06-22 17:16:16'
      }, {'data': 6370, 'time': '2017-06-22 17:16:36'}, {
        'data': 3966,
        'time': '2017-06-22T17:16:56.253123'
      }, {
        'data': 6075, 'time': '2017-06-22 17:17:16'
      }, {'data': 2753, 'time': '2017-06-22 17:17:36'}
      ],
      [{'data': 3256, 'time': '2017-06-22 17:01:16'}, {
        'data': 1338,
        'time': '2017-06-22 17:01:36'
      }, {'data': 4646, 'time': '2017-06-22 17:01:56'}, {
        'data': 6379,
        'time': '2017-06-22 17:02:16'
      }, {'data': 2872, 'time': '2017-06-22 17:02:36'}, {
        'data': 9584,
        'time': '2017-06-22 17:02:56'
      }, {'data': 6385, 'time': '2017-06-22 17:03:16'}, {
        'data': 1661,
        'time': '2017-06-22 17:03:36'
      }, {'data': 2921, 'time': '2017-06-22 17:03:56'}, {
        'data': 3087,
        'time': '2017-06-22 17:04:16'
      }, {'data': 9514, 'time': '2017-06-22 17:04:36'}, {
        'data': 2251,
        'time': '2017-06-22 17:04:56'
      }, {'data': 9592, 'time': '2017-06-22 17:05:16'}, {
        'data': 1846,
        'time': '2017-06-22 17:05:36'
      }, {'data': 9508, 'time': '2017-06-22 17:05:56'}, {
        'data': 2787,
        'time': '2017-06-22 17:06:16'
      }, {'data': 7246, 'time': '2017-06-22 17:06:36'}, {
        'data': 2543,
        'time': '2017-06-22 17:06:56'
      }, {'data': 4258, 'time': '2017-06-22 17:07:16'}, {
        'data': 5142,
        'time': '2017-06-22 17:07:36'
      }, {'data': 6821, 'time': '2017-06-22 17:07:56'}, {
        'data': 1585,
        'time': '2017-06-22 17:08:16'
      }, {'data': 435, 'time': '2017-06-22 17:08:36'}, {
        'data': 6300,
        'time': '2017-06-22 17:08:56'
      }, {'data': 649, 'time': '2017-06-22 17:09:16'}, {
        'data': 3115,
        'time': '2017-06-22 17:09:36'
      }, {'data': 701, 'time': '2017-06-22 17:09:56'}, {
        'data': 4965,
        'time': '2017-06-22 17:10:16'
      }, {'data': 4072, 'time': '2017-06-22 17:10:36'}, {
        'data': 5592,
        'time': '2017-06-22 17:10:56'
      }, {'data': 5367, 'time': '2017-06-22 17:11:16'}, {
        'data': 2875,
        'time': '2017-06-22 17:11:36'
      }, {'data': 1757, 'time': '2017-06-22 17:11:56'}, {
        'data': 9794,
        'time': '2017-06-22 17:12:16'
      }, {'data': 2629, 'time': '2017-06-22 17:12:36'}, {
        'data': 6911,
        'time': '2017-06-22 17:12:56'
      }, {'data': 3976, 'time': '2017-06-22 17:13:16'}, {
        'data': 2245,
        'time': '2017-06-22 17:13:36'
      }, {'data': 9648, 'time': '2017-06-22 17:13:56'}, {
        'data': 2198,
        'time': '2017-06-22 17:14:16'
      }, {'data': 7248, 'time': '2017-06-22 17:14:36'}, {
        'data': 7014,
        'time': '2017-06-22 17:14:56'
      }, {'data': 1992, 'time': '2017-06-22 17:15:16'}, {
        'data': 5253,
        'time': '2017-06-22 17:15:36'
      }, {'data': 2747, 'time': '2017-06-22 17:15:56'}, {
        'data': 3343,
        'time': '2017-06-22 17:16:16'
      }, {'data': 4370, 'time': '2017-06-22 17:16:36'}, {
        'data': 5966,
        'time': '2017-06-22T17:16:56.253123'
      }, {
        'data': 4075, 'time': '2017-06-22 17:17:16'
      }, {'data': 8753, 'time': '2017-06-22 17:17:36'}
      ]
    ]
  }

  // 全局变量
  let width = parseInt(d3.select('.line-box').style('width'))
  let height = parseInt(d3.select('.line-box').style('height'))
  let lineWidth = width - paddingL - paddingR
  let lineHeight = height - paddingT - paddingB
  let svg = d3.select('.line-chart-d3')
    .append('svg')
    .attr('width', width)
    .attr('height', height)

  // 定义图表组, 坐标系组, legend组, tip组
  let chartG, xAxisG, yAxisG, legendsG, tipsG, zoomG

  // 时间比例尺, 线性比例尺, 坐标轴
  let xScale = d3.scaleTime()
      .domain([new Date(d3.min(lineData.xAxis.data)), new Date(d3.max(lineData.xAxis.data))])
      .range([0, lineWidth]),
    zoomScale = d3.scaleTime()
      .domain([new Date(d3.min(lineData.xAxis.data)), new Date(d3.max(lineData.xAxis.data))])
      .range([0, lineWidth]),
    yScale = d3.scaleLinear()
      .domain([0, getMax()])
      .range([lineHeight, 0]),
    xAxis,
    yAxis

  media() // 自适应处理
  drawD3Chart() // 画图
  drawTips() // tips控制
  chartZoom() // 选区控制

  function drawD3Chart () {
    drawTitle() // 绘制title
    drawLegend() // 绘制legend
    drawAxis() // 绘制坐标系
    drawLine() // 绘制折线
    // svgZoom() // 缩放
  }

  function drawTitle () {
    d3.select('.chart-title')
      .text(lineData.title)
      .style('top', () => {
        let top = (paddingT - parseInt(d3.select('.chart-title').style('height'))) / 2
        return top + 'px'
      })
      .style('left', paddingL + 'px')
  }
  function drawLegend () {
    legendsG = d3.select('.legends-group')
    let legendItemG = legendsG.selectAll('.legend-item').data(lineData.legend)
    let enterLegendItem = legendItemG.enter()

    // update
    legendItemG
      .selectAll('.legend-i')
      .style('background-color', (d, i) => {
        return color[i]
      })
    legendItemG
      .selectAll('legend-text')
      .text((d) => {
        return d
      })
    // add
    let legendDiv = enterLegendItem.append('div')
      .attr('class', (d, i) => {
        return 'legend-item legend-item' + i
      })
    legendDiv.append('i')
      .attr('class', 'legend-i')
      .style('background-color', (d, i) => {
        return color[i]
      })
      .on('click', function (d, i) {
        let opacity = parseInt(d3.select(this).style('opacity'))
        d3.select(this).style('opacity', (opacity === 1) ? 0.5 : 1)

        d3.select('.chart-group').select('.area-group')
          .select('.line-area-item' + i)
          .transition()
          .duration(200)
          .attr('opacity', (opacity === 1) ? 0 : 1)
        d3.select('.chart-group').select('.path-group')
          .select('.line-path-item' + i)
          .transition()
          .duration(200)
          .attr('stroke-opacity', (opacity === 1) ? 0 : 1)
        d3.select('.chart-group').select('.circle-group')
          .select('.line-ciecle-item' + i)
          .transition()
          .duration(200)
          .attr('opacity', (opacity === 1) ? 0 : 1)
      })
    legendDiv.append('span')
      .attr('class', 'legend-text')
      .text((d) => {
        return d
      })
    legendsG
      .style('top', () => {
        let top = (paddingT - parseInt(d3.select('.legend-item').style('height'))) / 2
        return top + 'px'
      })
      .style('right', paddingR + 'px')

    // del
    legendItemG.exit().remove()
  }
  function drawAxis () {
    // x轴坐标系设置
    xAxis = d3.axisBottom(xScale)
      .ticks(5)
      .tickFormat(d3.timeFormat('%Y-%m-%d %H:%M:%S'))
    // 绘制x轴
    xAxisG = svg.select('.xAxis')
      .call(xAxis)
      .attr('transform', 'translate(' + paddingL + ',' + (height - paddingB) + ')')
    if (xAxisG.empty()) {
      xAxisG = svg.append('g')
        .call(xAxis)
        .attr('class', 'xAxis')
        .attr('transform', 'translate(' + paddingL + ',' + (height - paddingB) + ')')
        .append('text')
        .text(lineData.xAxis.title)
        .attr('stroke-width', 0)
        .attr('fill', 'black')
        .attr('transform', 'translate(' + lineWidth + ', 0)')
        .attr('dx', '1rem')
    }

    // y轴坐标系设置
    yAxis = d3.axisLeft()
      .scale(yScale)
      .ticks(5)
    // 绘制y轴
    yAxisG = svg.select('.yAxis')
      .call(yAxis)
      .attr('transform', 'translate(' + paddingL + ',' + paddingT + ')')
    if (yAxisG.empty()) {
      yAxisG = svg.append('g')
        .call(yAxis)
        .attr('class', 'yAxis')
        .attr('transform', 'translate(' + paddingL + ',' + paddingT + ')')
        .append('text')
        .text(lineData.yAxis.title)
        .attr('stroke-width', 0)
        .attr('fill', 'black')
        .attr('text-anthor', 'middle')
    }
  }
  function drawLine () {
    chartG = svg.selectAll('.chart-group')
    if (chartG.empty()) {
      chartG = svg.append('g')
        .attr('class', 'chart-group')
      // 隐藏多余的内容
      chartG.append('defs')
        .append('clipPath')
        .attr('id', 'clip')
        .append('rect')
        .attr('width', lineWidth)
        .attr('height', lineHeight)
        .attr('x', paddingL)
        .attr('y', paddingT)
      chartG.attr('clip-path', 'url(#clip)')
      chartG.append('g')
        .attr('class', 'area-group')
      chartG.append('g')
        .attr('class', 'path-group')
      chartG.append('g')
        .attr('class', 'circle-group')
    }
    drawArea() // 绘制路径背景 -----> 动画有问题
    drawPath() // 绘制路径
    drawCircle() // 绘制圆点
  }
  function drawArea () {
    let areaG = chartG.selectAll('.area-group')
    // 区域生成器，设置x y y0的取值
    let areaLine = d3.area()
      .x((d) => {
        return xScale(new Date(d.time))
      })
      .y0(() => {
        return height - paddingB
      })
      .y1((d) => {
        return yScale(d.data) + paddingT
      })

    let areaPath = areaG.selectAll('.line-area-item').data(lineData.series)
    let enterAreaPath = areaPath.enter()
    // update
    areaPath.attr('d', (d) => {
      return areaLine(d)
    })
    // add
    enterAreaPath.append('path')
      .attr('class', (d, i) => {
        return 'line-area-item line-area-item' + i
      })
      .attr('d', (d) => {
        return areaLine(d)
      })
      .attr('stroke', 'none')
      .attr('fill', (d, i) => {
        return color[i]
      })
      .attr('fill-opacity', '.3')
      .attr('transform', 'translate(' + paddingL + ')')
    /*enterAreaPath.append('rect')
     .attr('class', 'path-area-mark')
     .attr('width', lineWidth)
     .attr('height', lineHeight)
     .attr('x', paddingL + 1)
     .attr('y', paddingT)
     .attr('fill', '#fff')
     .attr('transform-origin', 'right center')
     .transition()
     .duration(1000)
     .attr('transform', 'scale(0, 1)')*/
    // del
    areaPath.exit().remove()
  }
  function drawPath () {
    let pathG = chartG.selectAll('.path-group')
    // 线段生成器，设置x y的取值
    let line = d3.line()
      .x((d) => {
        return xScale(new Date(d.time))
      })
      .y((d) => {
        return yScale(d.data) + paddingT
      })

    let path = pathG.selectAll('.line-path-item').data(lineData.series)
    let enterPath = path.enter()
    // update
    path
      .attr('d', (d) => {
        return line(d)
      })
      .attr('stroke-dasharray', function () {
        return this.getTotalLength()
      })
      .attr('stroke-dashoffset', function () {
        let lastOffSet = d3.select(this).attr('data-offset')
        d3.select(this).attr('data-offset', this.getTotalLength())
        let newOffSet = this.getTotalLength() - lastOffSet
        return newOffSet > 0 ? newOffSet : 0
      })
      .transition()
      .duration(500)
      .attr('stroke-dashoffset', 0)

    enterPath.append('path').attr('class', (d, i) => {
      return 'line-path-item line-path-item' + i
    })
      .attr('d', (d) => {
        return line(d)
      })
      .attr('stroke', function (d, i) {
        return color[i]
      })
      .attr('fill', 'none')
      .attr('transform', 'translate(' + paddingL + ')')
      .attr('stroke-dasharray', function () {
        d3.select(this).attr('data-offset', this.getTotalLength())
        return this.getTotalLength()
      })
      .attr('stroke-dashoffset', function () {
        return this.getTotalLength()
      })
      .transition()
      .duration(1000)
      .attr('stroke-dashoffset', 0)

    // del
    path.exit().remove()
  }
  function drawCircle () {
    let circleG = chartG.selectAll('.circle-group')

    let circleItemG = circleG.selectAll('.line-ciecle-item')
      .data(lineData.series)
    let enterCircleItemG = circleItemG.enter()

    // add
    enterCircleItemG.append('g')
      .attr('class', (d, i) => {
        return 'line-ciecle-item line-ciecle-item' + i
      })
      .attr('transform', 'translate(' + paddingL + ', ' + paddingT + ')')
      .attr('fill', (d, i) => {
        return color[i]
      })
    // del
    circleItemG.exit().remove()

    lineData.series.forEach((item, idx) => {
      let parentG = svg.selectAll('.line-ciecle-item' + idx)
      let circle = parentG.selectAll('circle')
        .data(item)
      let enterCircle = circle.enter()
      // update
      circle.attr('cx', (d) => {
        return xScale(new Date(d.time))
      })
        .attr('cy', (d) => {
          return yScale(d.data)
        })
      // add
      enterCircle.append('circle')
        .attr('cx', (d) => {
          return xScale(new Date(d.time))
        })
        .attr('cy', (d) => {
          return yScale(d.data)
        })
        .attr('r', 3.5)
        .style('cursor', 'pointer')
        .attr('fill-opacity', 0)
        .transition()
        .duration(1000)
        .attr('fill-opacity', 1)
      // del
      circle.exit().remove()
    })
  }

  function drawTips () {
    tipsG = svg.append('g')
      .attr('class', 'tips-group')
    tipsG.append('rect')
      .attr('class', 'mousemove-rect')
      .attr('width', lineWidth)
      .attr('height', lineHeight)
      .attr('x', paddingL)
      .attr('y', paddingT)
      .attr('fill', 'none')
      .style('pointer-events', 'all')
      .on('mouseover', function () {
        d3.select('.tips-content').transition().duration(200).style('display', 'block')
        d3.select('.tips-line-groups').transition().duration(200).style('display', 'block')
      })
      .on('mouseout', function () {
        d3.select('.tips-content').transition().duration(200).style('display', 'none')
        d3.select('.tips-line-groups').transition().duration(200).style('display', 'none')
      })
      .on('mousemove', showTip)
  }
  function showTip () {
    // 获取当前index
    var bisect = d3.bisector(function (d) {
      return new Date(d)
    }).left

    // 获取x轴坐标
    let x0 = xScale.invert(d3.mouse(this)[0] - paddingL),
      i = bisect(lineData.xAxis.data, x0),
      d0 = lineData.xAxis.data[i - 1],
      d1 = lineData.xAxis.data[i],
      d = new Date((x0 - d0) > (d1 - x0) ? d1 : d0)

    // 获取交点 y轴坐标
    let points = []
    lineData.series.forEach((item, idx) => {
      item.forEach((ditem) => {
        if (Date.parse(ditem.time) === Date.parse(d)) {
          points.push(ditem.data)
        }
      })
    })

    // 绘制垂直线以及圆点
    let tipsLineG = tipsG.selectAll('.tips-line-groups')
    tipsLineG.selectAll('.tips-line').attr('x1', xScale(d) + paddingL)
      .attr('x2', xScale(d) + paddingL)
    if (tipsLineG.empty()) {
      tipsG.append('g')
        .attr('class', 'tips-line-groups')
        .append('line')
        .attr('class', 'tips-line')
        .attr('x1', xScale(d))
        .attr('y1', paddingT)
        .attr('x2', xScale(d))
        .attr('y2', height - paddingB)
        .attr('stroke', '#999')
    }
    let tipsLineCircle = tipsLineG.selectAll('.tips-circle').data(points)
    tipsLineCircle
      .attr('cx', xScale(d) + paddingL)
      .attr('cy', (d) => {
        return yScale(d) + paddingT
      })
      .attr('opacity', (d, i) => {
        let opacity = d3.selectAll('.legend-item' + i).selectAll('.legend-i').style('opacity')
        opacity = (parseInt(opacity) === 1) ? 1 : 0
        return opacity
      })
    let enterTipsLineCircle = tipsLineCircle.enter()
    enterTipsLineCircle.append('circle')
      .attr('class', 'tips-circle')
      .attr('r', 5)
      .attr('cx', xScale(d) + paddingL)
      .attr('cy', (d) => {
        return yScale(d) + paddingT
      })
      .attr('fill', (d, i) => {
        return color[i]
      })
      .attr('opacity', (d, i) => {
        let opacity = d3.selectAll('.legend-item' + i).selectAll('.legend-i').style('opacity')
        opacity = (parseInt(opacity) === 1) ? 1 : 0
        return opacity
      })
    tipsLineCircle.exit().remove()

    // tip框填充相应文字数据
    let timeFormat = d3.timeFormat('%Y-%m-%d %H:%M:%S')
    let tipsContent = d3.selectAll('.tips-content')
    let tipsTitle = tipsContent.selectAll('.tips-title')
    tipsTitle.text('时间: ' + timeFormat(d))
    if (tipsTitle.empty()) {
      tipsContent.append('p')
        .attr('class', 'tips-title')
        .text('时间: ' + timeFormat(d))
    }
    let tipItem = tipsContent.selectAll('.tip-item').data(points)
    // update
    tipItem.style('display', (d, i) => {
      let opacity = d3.selectAll('.legend-item' + i).selectAll('.legend-i').style('opacity')
      opacity = (parseInt(opacity) === 1) ? 'inline-block' : 'none'
      return opacity
    })
    tipItem.select('i')
      .style('background-color', (d, i) => {
        return color[i]
      })
    tipItem.select('span')
      .text((d, i) => {
        return lineData.legend[i] + ' : ' + d
      })
    // add
    let enterTipItem = tipItem.enter()
    let tipItemDiv = enterTipItem
      .append('div')
      .attr('class', 'tip-item')
      .style('display', (d, i) => {
        let opacity = d3.selectAll('.legend-item' + i).selectAll('.legend-i').style('opacity')
        opacity = (parseInt(opacity) === 1) ? 'inline-block' : 'none'
        return opacity
      })
    tipItemDiv.append('i')
      .attr('class', 'tip-i')
      .style('background-color', (d, i) => {
        return color[i]
      })
    tipItemDiv.append('span')
      .attr('class', 'tip-text')
      .text((d, i) => {
        return lineData.legend[i] + ' : ' + d
      })
    // del
    tipItem.exit().remove()

    // tip框位置处理 边界处理
    let svgCenterW = width / 2, svgCenterH = height / 2, tipsL, tipsT
    if (d3.mouse(this)[0] > svgCenterW) {
      tipsL = d3.mouse(this)[0] - parseInt(tipsContent.style('width')) - 20 + 'px'
    } else {
      tipsL = d3.mouse(this)[0] + 20 + 'px'
    }
    if (d3.mouse(this)[1] > svgCenterH) {
      tipsT = d3.mouse(this)[1] - parseInt(tipsContent.style('height')) - 20 + 'px'
    } else {
      tipsT = d3.mouse(this)[1] + 20 + 'px'
    }
    tipsContent.style('left', tipsL)
      .style('top', tipsT)
  }

  function media () {
    window.onresize = function () {
      let docWidth = document.body.clientWidth
      if (docWidth !== width) {
        width = document.body.clientWidth
        lineWidth = width - paddingL - paddingR
        svg.attr('width', width)
        drawLine()
      }
    }
  }

  function chartZoom () {
    zoomG = svg.selectAll('.zoom-group')
    if (zoomG.empty()) {
      zoomG = svg.append('g')
        .attr('class', 'zoom-group')
    }
    // 矩形条
    zoomG.append('rect')
      .attr('class', 'zoom-rect-box')
      .attr('width', lineWidth)
      .attr('height', 20)
      .attr('x', paddingL)
      .attr('y', height - paddingB / 2)
      .attr('stroke', '#ccc')
      .attr('fill', 'none')
    zoomG.append('rect')
      .attr('class', 'zoom-rect')
      .attr('width', lineWidth)
      .attr('height', 20)
      .attr('x', paddingL)
      .attr('y', height - paddingB / 2)
      .attr('stroke', 'none')
      .attr('fill', color[0])
      .attr('fill-opacity', 0.5)

    // 两端滑块
    let drag = d3.drag()
      .on('drag', function (d, i) {
        // 滑块位置控制
        let x = d3.mouse(this)[0]
        if (parseInt(d3.mouse(this)[0]) <= parseInt(paddingL)) {
          x = paddingL
        } else if (parseInt(d3.mouse(this)[0]) >= parseInt(width - paddingR)) {
          x = width - paddingR - 10
        }
        d3.select(this).select('.rect-box')
          .attr('x', x)
          .attr('data-x', x)

        // 控制条宽度以及位置更改
        let xA = parseInt(d3.select('.rect-box0').attr('data-x'))
        let xB = parseInt(d3.select('.rect-box1').attr('data-x'))
        d3.select('.zoom-rect')
          .attr('width', (xB - xA + 10) > 0 ? (xB - xA + 10) : xA - xB)
          .attr('x', (xB - xA + 10) > 0 ? xA : xB + 10)

        // 计算x轴 新的日期定义域【】值域【0，width】
        let x0 = zoomScale.invert(xA - paddingL)
        let x1 = zoomScale.invert(xB + 10 - paddingL)
        xScale.domain([x0, x1])
        drawAxis()
        drawLine()
      })
    let rectData = [
      {
        width: 10,
        height: 20,
        x: paddingL,
        y: height - paddingB / 2
      },
      {
        width: 10,
        height: 20,
        x: width - paddingR - 10,
        y: height - paddingB / 2
      }
    ]
    let zoomMark = zoomG.selectAll('g').data(rectData)
    let enterZoomMark = zoomMark.enter()
    enterZoomMark.append('g').attr('class', (d, i) => {
      return 'zoom-mark zoom-mark' + i
    })
      .style('cursor', 'pointer')
      .call(drag)
      .append('rect')
      .attr('class', (d, i) => {
        return 'rect-box rect-box' + i
      })
      .attr('width', (d) => {
        return d.width
      })
      .attr('height', (d) => {
        return d.height
      })
      .attr('x', (d) => {
        return d.x
      })
      .attr('y', (d) => {
        return d.y
      })
      .attr('data-x', (d) => {
        return d.x
      })
      .attr('stroke', 'none')
      .attr('fill', color[0])
  }

  // 方法
  function getMax () {
    let maxData = []
    lineData.series.forEach((item, idx) => {
      let itemMax = d3.max(item, (d) => {
        return d.data
      })
      maxData.push(itemMax)
    })
    return d3.max(maxData)
  }

</script>
</html>
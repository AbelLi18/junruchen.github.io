<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 -- line</title>
  <style>
    * {
      box-sizing: border-box;
    }

    p, div {
      padding: 0;
      margin: 0;
    }

    svg {
      border: 1px solid;
    }

    .line-box {
      width: 100%;
      height: 340px;
    }

    .line-chart-d3 {
      position: relative;
    }

    .chart-title {
      position: absolute;
      font-size: 20px;
      color: #333;
    }

    .legends-group, .tips-content, .back-group {
      position: absolute;
      font-size: 12px;
    }

    .tips-content {
      display: none;
      padding: 5px;
      border-radius: 4px;
      min-width: 100px;
      max-width: 200px;
      background-color: rgba(0, 0, 0, .4);
      color: #fff;
    }

    .legends-group .legend-item {
      display: inline-block;
      color: #333;
      padding-left: 10px;
    }

    .legends-group .legend-item .legend-i, .tips-content .tip-item .tip-i {
      display: inline-block;
      vertical-align: middle;
      height: 13px;
      margin-right: 5px;
    }

    .legends-group .legend-item .legend-i {
      opacity: 1;
      width: 23px;
      border-radius: 3px;
      cursor: pointer;
    }

    .tips-content .tip-item .tip-i {
      width: 13px;
      border-radius: 50%;
    }

    .back-group {
      display: none;
      top: 0;
      right: 0;
      background: rgba(255, 255, 255, .5);
      padding: 3px 13px;
      border: 1px solid #ddd;
      border-radius: 3px;
      outline: none;
      cursor: pointer;
    }

    .back-group:hover {
      border-color: #58a;
      color: #58a;
    }

  </style>
</head>
<body>
<div class="d3-container">
  <div class="line-box">

    <div class="line-chart-d3">
      <div class="chart-title"></div>
      <div class="legends-group"></div>
      <div class="tips-content"></div>
      <button class="back-group">返回</button>
    </div>

  </div>
</div>
</body>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
  // 用户指定
  let paddingT = 60
  let paddingB = 60
  let paddingL = 60
  let paddingR = 60
  let color = ['#5588AA', '#FFBB33', 'red', 'green', 'purple', 'black', '#cccccc']

  let lineData = {
    'tips': true,
    'drag': true,
    'zoom': true,
    'title': 'QPS',
    'legend': {
      'show': false,
      'data': ['WRITE', 'READ']
    },
    'yAxis': {
      'title': 'GDP',
      'multi': false
    },
    'xAxis': {
      'title': '日期',
      'data': ['2017-06-22 17:01:16', '2017-06-22 17:01:36', '2017-06-22 17:01:56', '2017-06-22 17:02:16', '2017-06-22 17:02:36', '2017-06-22 17:02:56', '2017-06-22 17:03:16', '2017-06-22 17:03:36', '2017-06-22 17:03:56', '2017-06-22 17:04:16', '2017-06-22 17:04:36', '2017-06-22 17:04:56', '2017-06-22 17:05:16', '2017-06-22 17:05:36', '2017-06-22 17:05:56', '2017-06-22 17:06:16', '2017-06-22 17:06:36', '2017-06-22 17:06:56', '2017-06-22 17:07:16', '2017-06-22 17:07:36', '2017-06-22 17:07:56', '2017-06-22 17:08:16', '2017-06-22 17:08:36', '2017-06-22 17:08:56', '2017-06-22 17:09:16', '2017-06-22 17:09:36', '2017-06-22 17:09:56', '2017-06-22 17:10:16', '2017-06-22 17:10:36', '2017-06-22 17:10:56', '2017-06-22 17:11:16', '2017-06-22 17:11:36', '2017-06-22 17:11:56', '2017-06-22 17:12:16', '2017-06-22 17:12:36', '2017-06-22 17:12:56', '2017-06-22 17:13:16', '2017-06-22 17:13:36', '2017-06-22 17:13:56', '2017-06-22 17:14:16', '2017-06-22 17:14:36', '2017-06-22 17:14:56', '2017-06-22 17:15:16', '2017-06-22 17:15:36', '2017-06-22 17:15:56', '2017-06-22 17:16:16', '2017-06-22 17:16:36', '2017-06-22 17:16:56', '2017-06-22 17:17:16', '2017-06-22 17:17:36']
    },
    'series': [
      [{'data': 3356, 'time': '2017-06-22 17:01:16'}, {
        'data': 3338,
        'time': '2017-06-22 17:01:36'
      }, {'data': 2646, 'time': '2017-06-22 17:01:56'}, {
        'data': 3379,
        'time': '2017-06-22 17:02:16'
      }, {'data': 4872, 'time': '2017-06-22 17:02:36'}, {
        'data': 3584,
        'time': '2017-06-22 17:02:56'
      }, {'data': 1985, 'time': '2017-06-22 17:03:16'}, {
        'data': 2661,
        'time': '2017-06-22 17:03:36'
      }, {'data': 2921, 'time': '2017-06-22 17:03:56'}, {
        'data': 4087,
        'time': '2017-06-22 17:04:16'
      }, {'data': 4514, 'time': '2017-06-22 17:04:36'}, {
        'data': 251,
        'time': '2017-06-22 17:04:56'
      }, {'data': 2592, 'time': '2017-06-22 17:05:16'}, {
        'data': 5846,
        'time': '2017-06-22 17:05:36'
      }, {'data': 5508, 'time': '2017-06-22 17:05:56'}, {
        'data': 4787,
        'time': '2017-06-22 17:06:16'
      }, {'data': 3246, 'time': '2017-06-22 17:06:36'}, {
        'data': 2543,
        'time': '2017-06-22 17:06:56'
      }, {'data': 3258, 'time': '2017-06-22 17:07:16'}, {
        'data': 4142,
        'time': '2017-06-22 17:07:36'
      }, {'data': 5821, 'time': '2017-06-22 17:07:56'}, {
        'data': 2585,
        'time': '2017-06-22 17:08:16'
      }, {'data': 35, 'time': '2017-06-22 17:08:36'}, {
        'data': 1300,
        'time': '2017-06-22 17:08:56'
      }, {'data': 4649, 'time': '2017-06-22 17:09:16'}, {
        'data': 2115,
        'time': '2017-06-22 17:09:36'
      }, {'data': 701, 'time': '2017-06-22 17:09:56'}, {
        'data': 1965,
        'time': '2017-06-22 17:10:16'
      }, {'data': 4072, 'time': '2017-06-22 17:10:36'}, {
        'data': 1592,
        'time': '2017-06-22 17:10:56'
      }, {'data': 2367, 'time': '2017-06-22 17:11:16'}, {
        'data': 175,
        'time': '2017-06-22 17:11:36'
      }, {'data': 2757, 'time': '2017-06-22 17:11:56'}, {
        'data': 3794,
        'time': '2017-06-22 17:12:16'
      }, {'data': 1629, 'time': '2017-06-22 17:12:36'}, {
        'data': 4911,
        'time': '2017-06-22 17:12:56'
      }, {'data': 4976, 'time': '2017-06-22 17:13:16'}, {
        'data': 245,
        'time': '2017-06-22 17:13:36'
      }, {'data': 3648, 'time': '2017-06-22 17:13:56'}, {
        'data': 4198,
        'time': '2017-06-22 17:14:16'
      }, {'data': 1248, 'time': '2017-06-22 17:14:36'}, {
        'data': 5314,
        'time': '2017-06-22 17:14:56'
      }, {'data': 1592, 'time': '2017-06-22 17:15:16'}, {
        'data': 1253,
        'time': '2017-06-22 17:15:36'
      }, {'data': 747, 'time': '2017-06-22 17:15:56'}, {
        'data': 2343,
        'time': '2017-06-22 17:16:16'
      }, {'data': 3370, 'time': '2017-06-22 17:16:36'}, {
        'data': 3966,
        'time': '2017-06-22T17:16:56'
      }, {
        'data': 1075, 'time': '2017-06-22 17:17:16'
      }, {'data': 2753, 'time': '2017-06-22 17:17:36'}
      ],
      [{'data': 3256, 'time': '2017-06-22 17:01:16'}, {
        'data': 1338,
        'time': '2017-06-22 17:01:36'
      }, {'data': 4646, 'time': '2017-06-22 17:01:56'}, {
        'data': 6379,
        'time': '2017-06-22 17:02:16'
      }, {'data': 2872, 'time': '2017-06-22 17:02:36'}, {
        'data': 9584,
        'time': '2017-06-22 17:02:56'
      }, {'data': 6385, 'time': '2017-06-22 17:03:16'}, {
        'data': 1661,
        'time': '2017-06-22 17:03:36'
      }, {'data': 2921, 'time': '2017-06-22 17:03:56'}, {
        'data': 3087,
        'time': '2017-06-22 17:04:16'
      }, {'data': 9514, 'time': '2017-06-22 17:04:36'}, {
        'data': 2251,
        'time': '2017-06-22 17:04:56'
      }, {'data': 9592, 'time': '2017-06-22 17:05:16'}, {
        'data': 1846,
        'time': '2017-06-22 17:05:36'
      }, {'data': 9508, 'time': '2017-06-22 17:05:56'}, {
        'data': 2787,
        'time': '2017-06-22 17:06:16'
      }, {'data': 7246, 'time': '2017-06-22 17:06:36'}, {
        'data': 2543,
        'time': '2017-06-22 17:06:56'
      }, {'data': 4258, 'time': '2017-06-22 17:07:16'}, {
        'data': 5142,
        'time': '2017-06-22 17:07:36'
      }, {'data': 6821, 'time': '2017-06-22 17:07:56'}, {
        'data': 1585,
        'time': '2017-06-22 17:08:16'
      }, {'data': 435, 'time': '2017-06-22 17:08:36'}, {
        'data': 6300,
        'time': '2017-06-22 17:08:56'
      }, {'data': 649, 'time': '2017-06-22 17:09:16'}, {
        'data': 3115,
        'time': '2017-06-22 17:09:36'
      }, {'data': 701, 'time': '2017-06-22 17:09:56'}, {
        'data': 4965,
        'time': '2017-06-22 17:10:16'
      }, {'data': 4072, 'time': '2017-06-22 17:10:36'}, {
        'data': 5592,
        'time': '2017-06-22 17:10:56'
      }, {'data': 5367, 'time': '2017-06-22 17:11:16'}, {
        'data': 2875,
        'time': '2017-06-22 17:11:36'
      }, {'data': 1757, 'time': '2017-06-22 17:11:56'}, {
        'data': 9794,
        'time': '2017-06-22 17:12:16'
      }, {'data': 2629, 'time': '2017-06-22 17:12:36'}, {
        'data': 6911,
        'time': '2017-06-22 17:12:56'
      }, {'data': 3976, 'time': '2017-06-22 17:13:16'}, {
        'data': 2245,
        'time': '2017-06-22 17:13:36'
      }, {'data': 9648, 'time': '2017-06-22 17:13:56'}, {
        'data': 2198,
        'time': '2017-06-22 17:14:16'
      }, {'data': 7248, 'time': '2017-06-22 17:14:36'}, {
        'data': 7014,
        'time': '2017-06-22 17:14:56'
      }, {'data': 1992, 'time': '2017-06-22 17:15:16'}, {
        'data': 5253,
        'time': '2017-06-22 17:15:36'
      }, {'data': 2747, 'time': '2017-06-22 17:15:56'}, {
        'data': 3343,
        'time': '2017-06-22 17:16:16'
      }, {'data': 4370, 'time': '2017-06-22 17:16:36'}, {
        'data': 5966,
        'time': '2017-06-22T17:16:56'
      }, {
        'data': 4075, 'time': '2017-06-22 17:17:16'
      }, {'data': 8753, 'time': '2017-06-22 17:17:36'}
      ]
    ]
  }

  // 全局变量
  let width = parseInt(d3.select('.line-box').style('width'))
  let height = parseInt(d3.select('.line-box').style('height'))
  let lineWidth = width - paddingL - paddingR
  let lineHeight = height - paddingT - paddingB
  let svg = d3.select('.line-chart-d3')
    .append('svg')
    .attr('width', width)
    .attr('height', height)

  // 定义图表组, 坐标系组, legend组, tip组
  let chartG, xAxisG, yAxisG, legendsG, tipsG, dragG

  // 时间比例尺, 线性比例尺, 坐标轴, 多y轴
  let xScale = d3.scaleTime()
      .domain([new Date(d3.min(lineData.xAxis.data)), new Date(d3.max(lineData.xAxis.data))])
      .range([0, lineWidth]),
    dragScale = xScale.copy(),
    zoomScale = xScale.copy(),
    yScale,
    y0Scale,
    xAxis,
    yAxis

  check() // 判断参数是否存在, 单个y还是多个等
  media() // 自适应处理

  function check () {
    if (lineData.title) {
      drawTitle() // 绘制title
    }

    if (lineData.legend.show && lineData.legend.data.length > 0) {
      drawLegend() // 绘制legend
    }

    if (lineData.yAxis.multi) {
      // multi === true
      y0Scale = d3.scaleLinear()
        .domain([0, getMax(0)])
        .range([lineHeight, 0])

      y0Axis = d3.axisRight()
        .scale(y0Scale)
        .ticks(5)
      // 绘制y轴
      y0AxisG = svg.select('.y0Axis')
        .call(y0Axis)
        .attr('transform', 'translate(' + width - paddingR + ',' + paddingT + ')')
      if (y0AxisG.empty()) {
        y0AxisG = svg.append('g')
          .call(y0Axis)
          .attr('class', 'y0Axis')
          .attr('transform', 'translate(' + (width - paddingR) + ',' + paddingT + ')')
          .append('text')
          .text(lineData.yAxis.title)
          .attr('stroke-width', 0)
          .attr('fill', 'black')
          .attr('text-anthor', 'middle')
      }
    }
    drawAxis() // 绘制坐标系
    drawLine() // 绘制折线

    if (lineData.tips) {
      drawTips() // tips控制
    }

    if (lineData.drag) {
      chartDrag() // 时间滑块控制 chartDrag与chartZoom最好值选择用一个
    }

    if (lineData.zoom) {
      chartZoom() // 鼠标滚轮以及触摸板控制
    }
  }

  function drawTitle () {
    d3.select('.chart-title')
      .text(lineData.title)
      .style('top', () => {
        let top = (paddingT - parseInt(d3.select('.chart-title').style('height'))) / 2
        return top + 'px'
      })
      .style('left', paddingL + 'px')
  }
  function drawLegend () {
    legendsG = d3.select('.legends-group')

    let legendItemG = legendsG.selectAll('.legend-item').data(lineData.legend.data)
    let enterLegendItem = legendItemG.enter()

    // update
    legendItemG
      .selectAll('.legend-i')
      .style('background-color', (d, i) => {
        return color[i]
      })
    legendItemG
      .selectAll('legend-text')
      .text((d) => {
        return d
      })
    // add
    let legendDiv = enterLegendItem.append('div')
      .attr('class', (d, i) => {
        return 'legend-item legend-item' + i
      })
    legendDiv.append('i')
      .attr('class', 'legend-i')
      .style('background-color', (d, i) => {
        return color[i]
      })
      .on('click', function (d, i) {
        let opacity = parseInt(d3.select(this).style('opacity'))
        d3.select(this).style('opacity', (opacity === 1) ? 0.5 : 1)

        d3.select('.chart-group').select('.area-group')
          .select('.line-area-item' + i)
          .transition()
          .duration(200)
          .attr('opacity', (opacity === 1) ? 0 : 1)
        d3.select('.chart-group').select('.path-group')
          .select('.line-path-item' + i)
          .transition()
          .duration(200)
          .attr('opacity', (opacity === 1) ? 0 : 1)
        d3.select('.chart-group').select('.circle-group')
          .select('.line-ciecle-item' + i)
          .transition()
          .duration(200)
          .attr('opacity', (opacity === 1) ? 0 : 1)
      })
    legendDiv.append('span')
      .attr('class', 'legend-text')
      .text((d) => {
        return d
      })
    legendsG
      .style('top', () => {
        let top = (paddingT - parseInt(d3.select('.legend-item').style('height'))) / 2
        return top + 'px'
      })
      .style('right', paddingR + 'px')

    // del
    legendItemG.exit().remove()
  }

  function drawAxis () {
    // x轴坐标系设置
    xAxis = d3.axisBottom(xScale)
      .ticks(5)
      .tickFormat(d3.timeFormat('%Y-%m-%d %H:%M:%S'))
    // 绘制x轴
    xAxisG = svg.select('.xAxis')
      .call(xAxis)
      .attr('transform', 'translate(' + paddingL + ',' + (height - paddingB) + ')')
    xAxisG.selectAll('.xAxis-title')
      .attr('transform', 'translate(' + lineWidth + ', 0)')
    xAxisG.selectAll('#clip-xAxisG').select('rect')
      .attr('width', lineWidth + paddingR)
    if (xAxisG.empty()) {
      xAxisG = svg.append('g')
        .call(xAxis)
        .attr('class', 'xAxis')
        .attr('transform', 'translate(' + paddingL + ',' + (height - paddingB) + ')')
      xAxisG.append('text')
        .attr('class', 'xAxis-title')
        .text(lineData.xAxis.title)
        .attr('stroke-width', 0)
        .attr('fill', 'black')
        .attr('transform', 'translate(' + lineWidth + ', 0)')
        .attr('dy', '1rem')
        .attr('text-anchor', 'start')
      // 隐藏多余的内容，主要用在drag时，防止x轴文字出边界
      xAxisG.append('defs')
        .append('clipPath')
        .attr('id', 'clip-xAxisG')
        .append('rect')
        .attr('width', lineWidth + paddingR)
        .attr('height', 20)
    }
    xAxisG.attr('clip-path', 'url(#clip-xAxisG)')

    // 线性比例尺
    yScale = d3.scaleLinear()
      .domain([0, getMax(1)])
      .range([lineHeight, 0])
    // y轴坐标系设置
    yAxis = d3.axisLeft()
      .scale(yScale)
      .ticks(5)
    // 绘制y轴
    yAxisG = svg.select('.yAxis')
      .call(yAxis)
      .attr('transform', 'translate(' + paddingL + ',' + paddingT + ')')
    if (yAxisG.empty()) {
      yAxisG = svg.append('g')
        .call(yAxis)
        .attr('class', 'yAxis')
        .attr('transform', 'translate(' + paddingL + ',' + paddingT + ')')
        .append('text')
        .text(lineData.yAxis.title)
        .attr('stroke-width', 0)
        .attr('fill', 'black')
        .attr('text-anthor', 'middle')
    }
  }
  function drawLine () {
    chartG = svg.selectAll('.chart-group')
    chartG.selectAll('#clip').select('rect')
      .attr('width', lineWidth)
      .attr('height', lineHeight + 5)
    if (chartG.empty()) {
      chartG = svg.append('g')
        .attr('class', 'chart-group')
      // 隐藏多余的内容
      chartG.append('defs')
        .append('clipPath')
        .attr('id', 'clip')
        .append('rect')
        .attr('width', lineWidth)
        .attr('height', lineHeight + 5)
        .attr('x', paddingL)
        .attr('y', paddingT - 5)
      chartG.attr('clip-path', 'url(#clip)')
      chartG.append('g')
        .attr('class', 'area-group')
      chartG.append('g')
        .attr('class', 'path-group')
      chartG.append('g')
        .attr('class', 'circle-group')
    }
    drawArea() // 绘制路径背景 -----> 动画有问题
    drawPath() // 绘制路径
    drawCircle() // 绘制圆点
  }
  function drawArea () {
    let areaG = chartG.selectAll('.area-group')
    // 区域生成器，设置x y y0的取值
    let areaLine = d3.area()
      .x((d) => {
        return xScale(new Date(d.time))
      })
      .y0(() => {
        return height - paddingB
      })

    let areaPath = areaG.selectAll('.line-area-item').data(lineData.series)
    let enterAreaPath = areaPath.enter()
    // update
    areaPath.attr('d', (d, i) => {
      if (lineData.yAxis.multi && i === 0) {
        areaLine.y1((d) => {
          return y0Scale(d.data) + paddingT
        })
      } else {
        areaLine.y1((d) => {
          return yScale(d.data) + paddingT
        })
      }
      return areaLine(d)
    })
    // add
    enterAreaPath.append('path')
      .attr('class', (d, i) => {
        return 'line-area-item line-area-item' + i
      })
      .attr('d', (d, i) => {
        if (lineData.yAxis.multi && i === 0) {
          areaLine.y1((d) => {
            return y0Scale(d.data) + paddingT
          })
        } else {
          areaLine.y1((d) => {
            return yScale(d.data) + paddingT
          })
        }
        return areaLine(d)
      })
      .attr('stroke', 'none')
      .attr('fill', (d, i) => {
        return color[i]
      })
      .attr('fill-opacity', '.3')
      .attr('transform', 'translate(' + paddingL + ')')
    // del
    areaPath.exit().remove()
  }
  function drawPath () {
    let pathG = chartG.selectAll('.path-group')
    // 线段生成器，设置x y的取值
    let line = d3.line()
      .x((d) => {
        return xScale(new Date(d.time))
      })

    let path = pathG.selectAll('.line-path-item').data(lineData.series)
    let enterPath = path.enter()
    // update
    path
      .attr('d', (d, i) => {
        if (lineData.yAxis.multi && i === 0) {
          line.y((dy) => {
            return y0Scale(dy.data) + paddingT
          })
        } else {
          line.y((dy) => {
            return yScale(dy.data) + paddingT
          })
        }
        return line(d)
      })
      .attr('stroke-dasharray', function () {
        return this.getTotalLength()
      })
      .attr('stroke-dashoffset', function () {
        let lastOffSet = d3.select(this).attr('data-offset')
        d3.select(this).attr('data-offset', this.getTotalLength())
        let newOffSet = this.getTotalLength() - lastOffSet
        return newOffSet > 0 ? newOffSet : 0
      })
      .transition()
      .duration(500)
      .attr('stroke-dashoffset', 0)

    enterPath.append('path').attr('class', (d, i) => {
      return 'line-path-item line-path-item' + i
    })
      .attr('d', (d, i) => {
        if (lineData.yAxis.multi && i === 0) {
          line.y((dy) => {
            return y0Scale(dy.data) + paddingT
          })
        } else {
          line.y((dy) => {
            return yScale(dy.data) + paddingT
          })
        }
        return line(d)
      })
      .attr('stroke', function (d, i) {
        return color[i]
      })
      .attr('fill', 'none')
      .attr('transform', 'translate(' + paddingL + ')')
      .attr('stroke-dasharray', function () {
        d3.select(this).attr('data-offset', this.getTotalLength())
        return this.getTotalLength()
      })
      .attr('stroke-dashoffset', function () {
        return this.getTotalLength()
      })
      .transition()
      .duration(1000)
      .attr('stroke-dashoffset', 0)

    // del
    path.exit().remove()
  }
  function drawCircle () {
    let circleG = chartG.selectAll('.circle-group')

    let circleItemG = circleG.selectAll('.line-ciecle-item')
      .data(lineData.series)
    let enterCircleItemG = circleItemG.enter()

    // add
    enterCircleItemG.append('g')
      .attr('class', (d, i) => {
        return 'line-ciecle-item line-ciecle-item' + i
      })
      .attr('transform', 'translate(' + paddingL + ', ' + paddingT + ')')
      .attr('fill', (d, i) => {
        return color[i]
      })
    // del
    circleItemG.exit().remove()

    lineData.series.forEach((item, idx) => {
      let parentG = svg.selectAll('.line-ciecle-item' + idx)
      let circle = parentG.selectAll('circle')
        .data(item)
      let enterCircle = circle.enter()
      // update
      circle.attr('cx', (d) => {
        return xScale(new Date(d.time))
      })
        .attr('cy', (d) => {
          if (lineData.yAxis.multi && idx === 0) {
            return y0Scale(d.data)
          } else {
            return yScale(d.data)
          }
        })
      // add
      enterCircle.append('circle')
        .attr('cx', (d) => {
          return xScale(new Date(d.time))
        })
        .attr('cy', (d) => {
          if (lineData.yAxis.multi && idx === 0) {
            return y0Scale(d.data)
          } else {
            return yScale(d.data)
          }
        })
        .attr('r', 3.5)
        .style('cursor', 'pointer')
        .attr('fill-opacity', 0)
        .transition()
        .duration(1000)
        .attr('fill-opacity', .8)
      // del
      circle.exit().remove()
    })
  }

  function drawTips () {
    tipsG = svg.selectAll('.tips-group')
    if (tipsG.empty()) {
      tipsG = svg.append('g')
        .attr('class', 'tips-group')

    }
    let tipsRect = tipsG.selectAll('.mousemove-rect')
    if (tipsRect.empty()) {
      tipsRect = tipsG.append('rect')
        .attr('class', 'mousemove-rect')
    }
    tipsRect.attr('width', lineWidth)
      .attr('height', lineHeight)
      .attr('x', paddingL)
      .attr('y', paddingT)
      .attr('fill', 'none')
      .style('pointer-events', 'all')
      .on('mouseover', function () {
        d3.select('.tips-content').transition().duration(200).style('display', 'block')
        d3.select('.tips-line-groups').transition().duration(200).style('display', 'block')
      })
      .on('mouseout', function () {
        d3.select('.tips-content').transition().duration(200).style('display', 'none')
        d3.select('.tips-line-groups').transition().duration(200).style('display', 'none')
      })
      .on('mousemove', showTip)
  }
  function showTip () {
    // 获取当前index
    var bisect = d3.bisector(function (d) {
      return new Date(d)
    }).left

    // 获取x轴坐标
    let x0 = xScale.invert(d3.mouse(this)[0] - paddingL),
      i = bisect(lineData.xAxis.data, x0),
      d0 = lineData.xAxis.data[i - 1],
      d1 = lineData.xAxis.data[i],
      d = new Date((x0 - d0) > (d1 - x0) ? d1 : d0)

    // 获取交点 y轴坐标
    let points = []
    lineData.series.forEach((item, idx) => {
      item.forEach((ditem) => {
        if (Date.parse(ditem.time) === Date.parse(d)) {
          points.push(ditem.data)
        }
      })
    })

    // 绘制垂直线以及圆点
    let tipsLineG = tipsG.selectAll('.tips-line-groups')
    tipsLineG.selectAll('.tips-line').attr('x1', xScale(d) + paddingL)
      .attr('x2', xScale(d) + paddingL)
    if (tipsLineG.empty()) {
      tipsG.append('g')
        .attr('class', 'tips-line-groups')
        .append('line')
        .attr('class', 'tips-line')
        .attr('x1', xScale(d))
        .attr('y1', paddingT)
        .attr('x2', xScale(d))
        .attr('y2', height - paddingB)
        .attr('stroke', '#999')
    }
    let tipsLineCircle = tipsLineG.selectAll('.tips-circle').data(points)
    tipsLineCircle
      .attr('cx', xScale(d) + paddingL)
      .attr('cy', (d) => {
        return yScale(d) + paddingT
      })
      .attr('opacity', (d, i) => {
        if (!lineData.legend.show || lineData.legend.data.length <= 0) {
          return 1
        } else {
          let opacity = d3.selectAll('.legend-item' + i).selectAll('.legend-i').style('opacity')
          return (parseInt(opacity) === 1) ? 1 : 0
        }
      })
    let enterTipsLineCircle = tipsLineCircle.enter()
    enterTipsLineCircle.append('circle')
      .attr('class', 'tips-circle')
      .attr('r', 5)
      .attr('cx', xScale(d) + paddingL)
      .attr('cy', (d) => {
        return yScale(d) + paddingT
      })
      .attr('fill', (d, i) => {
        return color[i]
      })
      .attr('opacity', (d, i) => {
        if (!lineData.legend.show || lineData.legend.data.length <= 0) {
          return 1
        } else {
          let opacity = d3.selectAll('.legend-item' + i).selectAll('.legend-i').style('opacity')
          return (parseInt(opacity) === 1) ? 1 : 0
        }
      })
    tipsLineCircle.exit().remove()

    // tip框填充相应文字数据
    let timeFormat = d3.timeFormat('%Y-%m-%d %H:%M:%S')
    let tipsContent = d3.selectAll('.tips-content')
    let tipsTitle = tipsContent.selectAll('.tips-title')
    tipsTitle.text('时间: ' + timeFormat(d))
    if (tipsTitle.empty()) {
      tipsContent.append('p')
        .attr('class', 'tips-title')
        .text('时间: ' + timeFormat(d))
    }
    let tipItem = tipsContent.selectAll('.tip-item').data(points)
    // update
    tipItem.style('display', (d, i) => {
      if (!lineData.legend.show || lineData.legend.data.length <= 0) {
        return 'block'
      } else {
        let opacity = d3.selectAll('.legend-item' + i).selectAll('.legend-i').style('opacity')
        return (parseInt(opacity) === 1) ? 'block' : 0
      }
    })
    tipItem.select('i')
      .style('background-color', (d, i) => {
        return color[i]
      })
    tipItem.select('span')
      .text((d, i) => {
        if (!lineData.legend.show || lineData.legend.data.length <= 0) {
          return d
        } else {
          return lineData.legend.data[i] + ' : ' + d
        }
      })
    // add
    let enterTipItem = tipItem.enter()
    let tipItemDiv = enterTipItem
      .append('div')
      .attr('class', 'tip-item')
      .style('display', (d, i) => {
        if (!lineData.legend.show || lineData.legend.data.length <= 0) {
          return 'block'
        } else {
          let opacity = d3.selectAll('.legend-item' + i).selectAll('.legend-i').style('opacity')
          return (parseInt(opacity) === 1) ? 'block' : 0
        }
      })
    tipItemDiv.append('i')
      .attr('class', 'tip-i')
      .style('background-color', (d, i) => {
        return color[i]
      })
    tipItemDiv.append('span')
      .attr('class', 'tip-text')
      .text((d, i) => {
        if (!lineData.legend.show || lineData.legend.data.length <= 0) {
          return d
        } else {
          return lineData.legend.data[i] + ' : ' + d
        }
      })
    // del
    tipItem.exit().remove()

    // tip框位置处理 边界处理
    let svgCenterW = width / 2, svgCenterH = height / 2, tipsL, tipsT
    if (d3.mouse(this)[0] > svgCenterW) {
      tipsL = d3.mouse(this)[0] - parseInt(tipsContent.style('width')) - 20 + 'px'
    } else {
      tipsL = d3.mouse(this)[0] + 20 + 'px'
    }
    if (d3.mouse(this)[1] > svgCenterH) {
      tipsT = d3.mouse(this)[1] - parseInt(tipsContent.style('height')) - 20 + 'px'
    } else {
      tipsT = d3.mouse(this)[1] + 20 + 'px'
    }
    tipsContent.style('left', tipsL)
      .style('top', tipsT)
  }

  function chartDrag () {
    dragG = svg.selectAll('.drag-group')
    if (dragG.empty()) {
      dragG = svg.append('g')
        .attr('class', 'drag-group')
    }
    // 矩形条
    let dragRectBox = dragG.selectAll('.drag-rect-box')
    if (dragRectBox.empty()) {
      dragRectBox = dragG.append('rect')
        .attr('class', 'drag-rect-box')
    }
    dragRectBox.attr('width', lineWidth)
      .attr('height', 20)
      .attr('x', paddingL)
      .attr('y', height - paddingB / 2)
      .attr('stroke', '#ccc')
      .attr('fill', 'none')

    let dragRect = dragG.selectAll('.drag-rect')
    if (dragRect.empty()) {
      dragRect = dragG.append('rect')
        .attr('class', 'drag-rect')
    }
    dragRect.attr('width', lineWidth)
      .attr('height', 20)
      .attr('x', paddingL)
      .attr('y', height - paddingB / 2)
      .attr('stroke', 'none')
      .attr('fill', color[0])
      .attr('fill-opacity', 0.5)

    // 两端滑块
    let drag = d3.drag()
      .on('drag', function (d, i) {
        // 滑块位置控制
        let x = d3.mouse(this)[0]
        if (parseInt(d3.mouse(this)[0]) <= parseInt(paddingL)) {
          x = paddingL
        } else if (parseInt(d3.mouse(this)[0]) >= parseInt(width - paddingR)) {
          x = width - paddingR - 10
        }
        d3.select(this).select('.rect-box')
          .attr('x', x)
          .attr('data-x', x)

        // 控制条宽度以及位置更改
        let xA = parseInt(d3.select('.rect-box0').attr('data-x'))
        let xB = parseInt(d3.select('.rect-box1').attr('data-x'))
        d3.select('.drag-rect')
          .attr('width', (xB - xA + 10) > 0 ? (xB - xA + 10) : xA - xB)
          .attr('x', (xB - xA + 10) > 0 ? xA : xB + 10)

        // 计算x轴 新的日期定义域【】值域【0，width】
        let x0 = dragScale.invert(xA - paddingL)
        let x1 = dragScale.invert(xB + 10 - paddingL)
        if (xA > xB) {
          xScale.domain([x1, x0])
        } else {
          xScale.domain([x0, x1])
        }
        drawAxis()
        drawLine()
      })
    let rectData = [
      {
        width: 10,
        height: 20,
        x: paddingL,
        y: height - paddingB / 2
      },
      {
        width: 10,
        height: 20,
        x: width - paddingR - 10,
        y: height - paddingB / 2
      }
    ]
    let dragMark = dragG.selectAll('g').data(rectData)
    dragMark.select('.rect-box')
      .attr('x', (d) => {
        return d.x
      })
      .attr('y', (d) => {
        return d.y
      })
      .attr('data-x', (d) => {
        return d.x
      })
    // add
    let enterDragMark = dragMark.enter()
    enterDragMark.append('g')
      .attr('class', (d, i) => {
        return 'drag-mark drag-mark' + i
      })
      .style('cursor', 'pointer')
      .call(drag)
      .append('rect')
      .attr('class', (d, i) => {
        return 'rect-box rect-box' + i
      })
      .attr('width', (d) => {
        return d.width
      })
      .attr('height', (d) => {
        return d.height
      })
      .attr('x', (d) => {
        return d.x
      })
      .attr('y', (d) => {
        return d.y
      })
      .attr('data-x', (d) => {
        return d.x
      })
      .attr('stroke', 'none')
      .attr('fill', color[0])

    dragMark.exit().remove()
  }
  function chartZoom () {
    // 鼠标选区放大缩小
    // 滚轮／触摸板放大缩小---transform
    let zoom = d3.zoom()
      .on('start', function (d, i) {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'mousedown') {
          mouseChange(0, d3.mouse(this))
        }
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'wheel') {
          touchChange(0, d3.event.transform)
        }
      })
      .on('zoom', function () {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'mousemove') {
          mouseChange(1, d3.mouse(this))
        }
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'wheel') {
          touchChange(1, d3.event.transform)
        }
      })
      .on('end', function () {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'mouseup') {
          mouseChange(2, d3.mouse(this))
        }
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'wheel') {
          touchChange(2, d3.event.transform)
        }
      })
    svg.call(zoom)
  }

  function mouseChange (type, d) {
    d3.select('.tips-content').transition().duration(200).style('display', 'none')
    d3.select('.tips-line-groups').transition().duration(200).style('display', 'none')
    let mouseG = svg.selectAll('.mouse-group')
    let mouseRect = mouseG.selectAll('.mouse-rect')
    if (mouseRect.empty()) {
      mouseRect = svg.append('g')
        .attr('class', 'mouse-group')
        .append('rect')
        .attr('class', 'mouse-rect')
        .attr('fill', '#fff')
        .attr('stroke', '#ccc')
        .attr('opacity', .7)
        .attr('stroke-dasharray', '5, 5')
    }
    let dataX = mouseRect.attr('data-x'),
      dataY = mouseRect.attr('data-y')
    if (type === 0) {
      mouseRect.attr('x', d[0])
        .attr('y', d[1])
        .attr('width', 0)
        .attr('height', 0)
        .attr('data-x', d[0])
        .attr('data-y', d[1])
    } else if (type === 1) {
      let rectWidth = Math.abs(d[0] - dataX)
      let rectHeight = Math.abs(d[1] - dataY)
      mouseRect
        .attr('width', rectWidth <= 3 ? 0 : rectWidth)
        .attr('height', rectHeight <= 3 ? 0 : rectHeight)
        .attr('x', d[0] - dataX > 0 ? dataX : d[0])
        .attr('y', d[1] - dataY > 0 ? dataY : d[1])
    } else {
      if (Math.abs(d[0] - dataX) <= 3) {
        mouseRect.remove()
        return false
      }
      let x0 = zoomScale.invert(dataX - paddingL)
      let x1 = zoomScale.invert(d[0] - paddingL)
      if (dataX > d[0]) {
        xScale.domain([x1, x0])
      } else {
        xScale.domain([x0, x1])
      }
      zoomScale = xScale
      mouseRect.remove()
      drawAxis()
      drawLine()
      let backG = d3.selectAll('.back-group')
      backG.style('display', 'block')
        .style('right', paddingR + 'px')
        .style('top', paddingT + 'px')
        .on('click', function () {
          xScale
            .domain([new Date(d3.min(lineData.xAxis.data)), new Date(d3.max(lineData.xAxis.data))])
          drawAxis()
          drawLine()
          d3.select(this).style('display', 'none')
        })
    }
  }
  function touchChange (type, d) {
    console.log(type, d)
    /*let wheelRect = svg.selectAll('.wheel-group').selectAll('.wheel-rect')
     if (wheelRect.empty()) {
     wheelRect = svg.append('g')
     .attr('class', 'wheel-group')
     .append('rect')
     .attr('class', 'wheel-rect')
     .attr('data-k', d.k)
     .attr('data-x', d.x)
     }*/

    //console.log(type, d.x, d.k)
    /*if (type === 0) {
     wheelRect = svg.append('g')
     .attr('data-k', d.k)
     .attr('data-x', d.x)
     } else if (type === 1) {

     } else {

     }*/

    if (d.k > 1) {
      // 放大
      //let x = wheelRect.attr('data-x')
      // console.log('big-----', x, d.x)
    } else {
      // 缩小-->最小缩放到原始比例尺
    }
  }

  function media () {
    window.onresize = function () {
      let docWidth = document.body.clientWidth
      if (docWidth !== width) {
        width = document.body.clientWidth
        lineWidth = width - paddingL - paddingR
        svg.attr('width', width)
        xScale = d3.scaleTime()
          .domain([new Date(d3.min(lineData.xAxis.data)), new Date(d3.max(lineData.xAxis.data))])
          .range([0, lineWidth])
        dragScale = xScale.copy()
        zoomScale = xScale.copy()
        check()
      }
    }
  }

  // 方法
  function getMax (type) {
    let itemMax = d3.max(lineData.series[type], (d) => {
      return d.data
    })
    return itemMax
  }

</script>
</html>